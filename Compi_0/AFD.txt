Grammar:

Rule 0     S' -> start
Rule 1     start -> stmtlist
Rule 2     stmtlist -> stmtlist stmt ;
Rule 3     stmtlist -> empty
Rule 4     stmt -> LOCAL namelist = explist
Rule 5     stmt -> LOCAL namelist
Rule 6     stmt -> LOCAL FUNCTION function
Rule 7     stmt -> FUNCTION function
Rule 8     stmt -> FOR namelist IN explist DO stmtlist END
Rule 9     stmt -> FOR NAME = exp , exp , exp DO stmtlist END
Rule 10    stmt -> FOR NAME = exp , exp DO stmtlist END
Rule 11    stmt -> BREAK
Rule 12    stmt -> RETURN explist
Rule 13    stmt -> RETURN
Rule 14    stmt -> IF exp THEN stmtlist elsepart END
Rule 15    stmt -> WHILE exp DO stmtlist END
Rule 16    stmt -> DO stmtlist END
Rule 17    stmt -> functioncall
Rule 18    stmt -> varlist = explist
Rule 19    elsepart -> ELSEIF exp THEN stmtlist elsepart
Rule 20    elsepart -> ELSE stmtlist
Rule 21    elsepart -> empty
Rule 22    function -> NAME : NAME funcbody
Rule 23    function -> NAME funcbody
Rule 24    funcbody -> ( params ) stmtlist END
Rule 25    params -> namelist
Rule 26    params -> empty
Rule 27    namelist -> NAME , namelist
Rule 28    namelist -> NAME
Rule 29    varlist -> var , varlist
Rule 30    varlist -> var
Rule 31    var -> prefixexp . NAME
Rule 32    var -> prefixexp [ exp ]
Rule 33    var -> NAME
Rule 34    explist -> exp , explist
Rule 35    explist -> exp
Rule 36    exp -> { fieldlist }
Rule 37    exp -> prefixexp
Rule 38    exp -> FUNCTION funcbody
Rule 39    exp -> NUMBER
Rule 40    exp -> STRING
Rule 41    exp -> FALSE
Rule 42    exp -> TRUE
Rule 43    exp -> NIL
Rule 44    exp -> NOT exp  [precedence=left, level=6]
Rule 45    exp -> - exp  [precedence=left, level=6]
Rule 46    exp -> exp ^ exp  [precedence=right, level=8]
Rule 47    exp -> exp % exp  [precedence=left, level=5]
Rule 48    exp -> exp / exp  [precedence=left, level=5]
Rule 49    exp -> exp * exp  [precedence=left, level=5]
Rule 50    exp -> exp - exp  [precedence=left, level=4]
Rule 51    exp -> exp + exp  [precedence=left, level=4]
Rule 52    exp -> exp CONCAT exp  [precedence=right, level=7]
Rule 53    exp -> exp NE exp  [precedence=left, level=3]
Rule 54    exp -> exp EQ exp  [precedence=left, level=3]
Rule 55    exp -> exp GE exp  [precedence=left, level=3]
Rule 56    exp -> exp GT exp  [precedence=left, level=3]
Rule 57    exp -> exp LE exp  [precedence=left, level=3]
Rule 58    exp -> exp LT exp  [precedence=left, level=3]
Rule 59    exp -> exp AND exp  [precedence=left, level=2]
Rule 60    exp -> exp OR exp  [precedence=left, level=1]
Rule 61    prefixexp -> ( exp )
Rule 62    prefixexp -> functioncall
Rule 63    prefixexp -> prefixexp . NAME
Rule 64    prefixexp -> prefixexp [ exp ]
Rule 65    prefixexp -> NAME
Rule 66    functioncall -> prefixexp . NAME args
Rule 67    functioncall -> prefixexp args
Rule 68    args -> { fieldlist }
Rule 69    args -> ( explist )
Rule 70    args -> ( )
Rule 71    fieldlist -> field , fieldlist
Rule 72    fieldlist -> field
Rule 73    fieldlist -> empty
Rule 74    field -> NAME = exp
Rule 75    field -> [ exp ] = exp
Rule 76    empty -> <empty>

Unused terminals:

    UNTIL
    REPEAT

Terminals, with rules where they appear:

%                    : 47
(                    : 24 61 69 70
)                    : 24 61 69 70
*                    : 49
+                    : 51
,                    : 9 9 10 27 29 34 71
-                    : 45 50
.                    : 31 63 66
/                    : 48
:                    : 22
;                    : 2
=                    : 4 9 10 18 74 75
AND                  : 59
BREAK                : 11
CONCAT               : 52
DO                   : 8 9 10 15 16
ELSE                 : 20
ELSEIF               : 19
END                  : 8 9 10 14 15 16 24
EQ                   : 54
FALSE                : 41
FOR                  : 8 9 10
FUNCTION             : 6 7 38
GE                   : 55
GT                   : 56
IF                   : 14
IN                   : 8
LE                   : 57
LOCAL                : 4 5 6
LT                   : 58
NAME                 : 9 10 22 22 23 27 28 31 33 63 65 66 74
NE                   : 53
NIL                  : 43
NOT                  : 44
NUMBER               : 39
OR                   : 60
REPEAT               : 
RETURN               : 12 13
STRING               : 40
THEN                 : 14 19
TRUE                 : 42
UNTIL                : 
WHILE                : 15
[                    : 32 64 75
]                    : 32 64 75
^                    : 46
error                : 
{                    : 36 68
}                    : 36 68

Nonterminals, with rules where they appear:

args                 : 66 67
elsepart             : 14 19
empty                : 3 21 26 73
exp                  : 9 9 9 10 10 14 15 19 32 34 35 44 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 64 74 75 75
explist              : 4 8 12 18 34 69
field                : 71 72
fieldlist            : 36 68 71
funcbody             : 22 23 38
function             : 6 7
functioncall         : 17 62
namelist             : 4 5 8 25 27
params               : 24
prefixexp            : 31 32 37 63 64 66 67
start                : 0
stmt                 : 2
stmtlist             : 1 2 8 9 10 14 15 16 19 20 24
var                  : 29 30
varlist              : 18 29


state 0

    (0) S' -> . start
    (1) start -> . stmtlist
    (2) stmtlist -> . stmtlist stmt ;
    (3) stmtlist -> . empty
    (76) empty -> .
    LOCAL           reduce using rule 76 (empty -> .)
    FUNCTION        reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    BREAK           reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    DO              reduce using rule 76 (empty -> .)
    (               reduce using rule 76 (empty -> .)
    NAME            reduce using rule 76 (empty -> .)
    $end            reduce using rule 76 (empty -> .)

    start                          shift and go to state 1
    stmtlist                       shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> start .


state 2

    (1) start -> stmtlist .
    (2) stmtlist -> stmtlist . stmt ;
    (4) stmt -> . LOCAL namelist = explist
    (5) stmt -> . LOCAL namelist
    (6) stmt -> . LOCAL FUNCTION function
    (7) stmt -> . FUNCTION function
    (8) stmt -> . FOR namelist IN explist DO stmtlist END
    (9) stmt -> . FOR NAME = exp , exp , exp DO stmtlist END
    (10) stmt -> . FOR NAME = exp , exp DO stmtlist END
    (11) stmt -> . BREAK
    (12) stmt -> . RETURN explist
    (13) stmt -> . RETURN
    (14) stmt -> . IF exp THEN stmtlist elsepart END
    (15) stmt -> . WHILE exp DO stmtlist END
    (16) stmt -> . DO stmtlist END
    (17) stmt -> . functioncall
    (18) stmt -> . varlist = explist
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    (29) varlist -> . var , varlist
    (30) varlist -> . var
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (31) var -> . prefixexp . NAME
    (32) var -> . prefixexp [ exp ]
    (33) var -> . NAME
    $end            reduce using rule 1 (start -> stmtlist .)
    LOCAL           shift and go to state 5
    FUNCTION        shift and go to state 6
    FOR             shift and go to state 7
    BREAK           shift and go to state 10
    RETURN          shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    DO              shift and go to state 8
    (               shift and go to state 18
    NAME            shift and go to state 9

    stmt                           shift and go to state 4
    functioncall                   shift and go to state 14
    varlist                        shift and go to state 15
    prefixexp                      shift and go to state 16
    var                            shift and go to state 17

state 3

    (3) stmtlist -> empty .
    LOCAL           reduce using rule 3 (stmtlist -> empty .)
    FUNCTION        reduce using rule 3 (stmtlist -> empty .)
    FOR             reduce using rule 3 (stmtlist -> empty .)
    BREAK           reduce using rule 3 (stmtlist -> empty .)
    RETURN          reduce using rule 3 (stmtlist -> empty .)
    IF              reduce using rule 3 (stmtlist -> empty .)
    WHILE           reduce using rule 3 (stmtlist -> empty .)
    DO              reduce using rule 3 (stmtlist -> empty .)
    (               reduce using rule 3 (stmtlist -> empty .)
    NAME            reduce using rule 3 (stmtlist -> empty .)
    $end            reduce using rule 3 (stmtlist -> empty .)
    END             reduce using rule 3 (stmtlist -> empty .)
    ELSEIF          reduce using rule 3 (stmtlist -> empty .)
    ELSE            reduce using rule 3 (stmtlist -> empty .)


state 4

    (2) stmtlist -> stmtlist stmt . ;
    ;               shift and go to state 19


state 5

    (4) stmt -> LOCAL . namelist = explist
    (5) stmt -> LOCAL . namelist
    (6) stmt -> LOCAL . FUNCTION function
    (27) namelist -> . NAME , namelist
    (28) namelist -> . NAME
    FUNCTION        shift and go to state 21
    NAME            shift and go to state 22

    namelist                       shift and go to state 20

state 6

    (7) stmt -> FUNCTION . function
    (22) function -> . NAME : NAME funcbody
    (23) function -> . NAME funcbody
    NAME            shift and go to state 24

    function                       shift and go to state 23

state 7

    (8) stmt -> FOR . namelist IN explist DO stmtlist END
    (9) stmt -> FOR . NAME = exp , exp , exp DO stmtlist END
    (10) stmt -> FOR . NAME = exp , exp DO stmtlist END
    (27) namelist -> . NAME , namelist
    (28) namelist -> . NAME
    NAME            shift and go to state 26

    namelist                       shift and go to state 25

state 8

    (16) stmt -> DO . stmtlist END
    (2) stmtlist -> . stmtlist stmt ;
    (3) stmtlist -> . empty
    (76) empty -> .
    END             reduce using rule 76 (empty -> .)
    LOCAL           reduce using rule 76 (empty -> .)
    FUNCTION        reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    BREAK           reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    DO              reduce using rule 76 (empty -> .)
    (               reduce using rule 76 (empty -> .)
    NAME            reduce using rule 76 (empty -> .)

    stmtlist                       shift and go to state 27
    empty                          shift and go to state 3

state 9

    (65) prefixexp -> NAME .
    (33) var -> NAME .
    .               reduce using rule 65 (prefixexp -> NAME .)
    [               reduce using rule 65 (prefixexp -> NAME .)
    {               reduce using rule 65 (prefixexp -> NAME .)
    (               reduce using rule 65 (prefixexp -> NAME .)
    ,               reduce using rule 33 (var -> NAME .)
    =               reduce using rule 33 (var -> NAME .)


state 10

    (11) stmt -> BREAK .
    ;               reduce using rule 11 (stmt -> BREAK .)


state 11

    (12) stmt -> RETURN . explist
    (13) stmt -> RETURN .
    (34) explist -> . exp , explist
    (35) explist -> . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    ;               reduce using rule 13 (stmt -> RETURN .)
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    explist                        shift and go to state 28
    exp                            shift and go to state 29
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 12

    (14) stmt -> IF . exp THEN stmtlist elsepart END
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 42
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 13

    (15) stmt -> WHILE . exp DO stmtlist END
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 43
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 14

    (17) stmt -> functioncall .
    (62) prefixexp -> functioncall .
    ;               reduce using rule 17 (stmt -> functioncall .)
    .               reduce using rule 62 (prefixexp -> functioncall .)
    [               reduce using rule 62 (prefixexp -> functioncall .)
    {               reduce using rule 62 (prefixexp -> functioncall .)
    (               reduce using rule 62 (prefixexp -> functioncall .)


state 15

    (18) stmt -> varlist . = explist
    =               shift and go to state 44


state 16

    (66) functioncall -> prefixexp . . NAME args
    (67) functioncall -> prefixexp . args
    (63) prefixexp -> prefixexp . . NAME
    (64) prefixexp -> prefixexp . [ exp ]
    (31) var -> prefixexp . . NAME
    (32) var -> prefixexp . [ exp ]
    (68) args -> . { fieldlist }
    (69) args -> . ( explist )
    (70) args -> . ( )
    .               shift and go to state 45
    [               shift and go to state 47
    {               shift and go to state 48
    (               shift and go to state 49

    args                           shift and go to state 46

state 17

    (29) varlist -> var . , varlist
    (30) varlist -> var .
    ,               shift and go to state 50
    =               reduce using rule 30 (varlist -> var .)


state 18

    (61) prefixexp -> ( . exp )
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 51
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 19

    (2) stmtlist -> stmtlist stmt ; .
    LOCAL           reduce using rule 2 (stmtlist -> stmtlist stmt ; .)
    FUNCTION        reduce using rule 2 (stmtlist -> stmtlist stmt ; .)
    FOR             reduce using rule 2 (stmtlist -> stmtlist stmt ; .)
    BREAK           reduce using rule 2 (stmtlist -> stmtlist stmt ; .)
    RETURN          reduce using rule 2 (stmtlist -> stmtlist stmt ; .)
    IF              reduce using rule 2 (stmtlist -> stmtlist stmt ; .)
    WHILE           reduce using rule 2 (stmtlist -> stmtlist stmt ; .)
    DO              reduce using rule 2 (stmtlist -> stmtlist stmt ; .)
    (               reduce using rule 2 (stmtlist -> stmtlist stmt ; .)
    NAME            reduce using rule 2 (stmtlist -> stmtlist stmt ; .)
    $end            reduce using rule 2 (stmtlist -> stmtlist stmt ; .)
    END             reduce using rule 2 (stmtlist -> stmtlist stmt ; .)
    ELSEIF          reduce using rule 2 (stmtlist -> stmtlist stmt ; .)
    ELSE            reduce using rule 2 (stmtlist -> stmtlist stmt ; .)


state 20

    (4) stmt -> LOCAL namelist . = explist
    (5) stmt -> LOCAL namelist .
    =               shift and go to state 52
    ;               reduce using rule 5 (stmt -> LOCAL namelist .)


state 21

    (6) stmt -> LOCAL FUNCTION . function
    (22) function -> . NAME : NAME funcbody
    (23) function -> . NAME funcbody
    NAME            shift and go to state 24

    function                       shift and go to state 53

state 22

    (27) namelist -> NAME . , namelist
    (28) namelist -> NAME .
    ,               shift and go to state 54
    =               reduce using rule 28 (namelist -> NAME .)
    ;               reduce using rule 28 (namelist -> NAME .)
    IN              reduce using rule 28 (namelist -> NAME .)
    )               reduce using rule 28 (namelist -> NAME .)


state 23

    (7) stmt -> FUNCTION function .
    ;               reduce using rule 7 (stmt -> FUNCTION function .)


state 24

    (22) function -> NAME . : NAME funcbody
    (23) function -> NAME . funcbody
    (24) funcbody -> . ( params ) stmtlist END
    :               shift and go to state 55
    (               shift and go to state 57

    funcbody                       shift and go to state 56

state 25

    (8) stmt -> FOR namelist . IN explist DO stmtlist END
    IN              shift and go to state 58


state 26

    (9) stmt -> FOR NAME . = exp , exp , exp DO stmtlist END
    (10) stmt -> FOR NAME . = exp , exp DO stmtlist END
    (27) namelist -> NAME . , namelist
    (28) namelist -> NAME .
    =               shift and go to state 59
    ,               shift and go to state 54
    IN              reduce using rule 28 (namelist -> NAME .)


state 27

    (16) stmt -> DO stmtlist . END
    (2) stmtlist -> stmtlist . stmt ;
    (4) stmt -> . LOCAL namelist = explist
    (5) stmt -> . LOCAL namelist
    (6) stmt -> . LOCAL FUNCTION function
    (7) stmt -> . FUNCTION function
    (8) stmt -> . FOR namelist IN explist DO stmtlist END
    (9) stmt -> . FOR NAME = exp , exp , exp DO stmtlist END
    (10) stmt -> . FOR NAME = exp , exp DO stmtlist END
    (11) stmt -> . BREAK
    (12) stmt -> . RETURN explist
    (13) stmt -> . RETURN
    (14) stmt -> . IF exp THEN stmtlist elsepart END
    (15) stmt -> . WHILE exp DO stmtlist END
    (16) stmt -> . DO stmtlist END
    (17) stmt -> . functioncall
    (18) stmt -> . varlist = explist
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    (29) varlist -> . var , varlist
    (30) varlist -> . var
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (31) var -> . prefixexp . NAME
    (32) var -> . prefixexp [ exp ]
    (33) var -> . NAME
    END             shift and go to state 60
    LOCAL           shift and go to state 5
    FUNCTION        shift and go to state 6
    FOR             shift and go to state 7
    BREAK           shift and go to state 10
    RETURN          shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    DO              shift and go to state 8
    (               shift and go to state 18
    NAME            shift and go to state 9

    stmt                           shift and go to state 4
    functioncall                   shift and go to state 14
    varlist                        shift and go to state 15
    prefixexp                      shift and go to state 16
    var                            shift and go to state 17

state 28

    (12) stmt -> RETURN explist .
    ;               reduce using rule 12 (stmt -> RETURN explist .)


state 29

    (34) explist -> exp . , explist
    (35) explist -> exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               shift and go to state 61
    ;               reduce using rule 35 (explist -> exp .)
    )               reduce using rule 35 (explist -> exp .)
    DO              reduce using rule 35 (explist -> exp .)
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 30

    (36) exp -> { . fieldlist }
    (71) fieldlist -> . field , fieldlist
    (72) fieldlist -> . field
    (73) fieldlist -> . empty
    (74) field -> . NAME = exp
    (75) field -> . [ exp ] = exp
    (76) empty -> .
    NAME            shift and go to state 80
    [               shift and go to state 81
    }               reduce using rule 76 (empty -> .)

    fieldlist                      shift and go to state 77
    field                          shift and go to state 78
    empty                          shift and go to state 79

state 31

    (37) exp -> prefixexp .
    (63) prefixexp -> prefixexp . . NAME
    (64) prefixexp -> prefixexp . [ exp ]
    (66) functioncall -> prefixexp . . NAME args
    (67) functioncall -> prefixexp . args
    (68) args -> . { fieldlist }
    (69) args -> . ( explist )
    (70) args -> . ( )
    ,               reduce using rule 37 (exp -> prefixexp .)
    ^               reduce using rule 37 (exp -> prefixexp .)
    %               reduce using rule 37 (exp -> prefixexp .)
    /               reduce using rule 37 (exp -> prefixexp .)
    *               reduce using rule 37 (exp -> prefixexp .)
    -               reduce using rule 37 (exp -> prefixexp .)
    +               reduce using rule 37 (exp -> prefixexp .)
    CONCAT          reduce using rule 37 (exp -> prefixexp .)
    NE              reduce using rule 37 (exp -> prefixexp .)
    EQ              reduce using rule 37 (exp -> prefixexp .)
    GE              reduce using rule 37 (exp -> prefixexp .)
    GT              reduce using rule 37 (exp -> prefixexp .)
    LE              reduce using rule 37 (exp -> prefixexp .)
    LT              reduce using rule 37 (exp -> prefixexp .)
    AND             reduce using rule 37 (exp -> prefixexp .)
    OR              reduce using rule 37 (exp -> prefixexp .)
    ;               reduce using rule 37 (exp -> prefixexp .)
    THEN            reduce using rule 37 (exp -> prefixexp .)
    DO              reduce using rule 37 (exp -> prefixexp .)
    )               reduce using rule 37 (exp -> prefixexp .)
    ]               reduce using rule 37 (exp -> prefixexp .)
    }               reduce using rule 37 (exp -> prefixexp .)
    .               shift and go to state 82
    [               shift and go to state 83
    {               shift and go to state 48
    (               shift and go to state 49

    args                           shift and go to state 46

state 32

    (38) exp -> FUNCTION . funcbody
    (24) funcbody -> . ( params ) stmtlist END
    (               shift and go to state 57

    funcbody                       shift and go to state 84

state 33

    (39) exp -> NUMBER .
    ,               reduce using rule 39 (exp -> NUMBER .)
    ^               reduce using rule 39 (exp -> NUMBER .)
    %               reduce using rule 39 (exp -> NUMBER .)
    /               reduce using rule 39 (exp -> NUMBER .)
    *               reduce using rule 39 (exp -> NUMBER .)
    -               reduce using rule 39 (exp -> NUMBER .)
    +               reduce using rule 39 (exp -> NUMBER .)
    CONCAT          reduce using rule 39 (exp -> NUMBER .)
    NE              reduce using rule 39 (exp -> NUMBER .)
    EQ              reduce using rule 39 (exp -> NUMBER .)
    GE              reduce using rule 39 (exp -> NUMBER .)
    GT              reduce using rule 39 (exp -> NUMBER .)
    LE              reduce using rule 39 (exp -> NUMBER .)
    LT              reduce using rule 39 (exp -> NUMBER .)
    AND             reduce using rule 39 (exp -> NUMBER .)
    OR              reduce using rule 39 (exp -> NUMBER .)
    ;               reduce using rule 39 (exp -> NUMBER .)
    THEN            reduce using rule 39 (exp -> NUMBER .)
    DO              reduce using rule 39 (exp -> NUMBER .)
    )               reduce using rule 39 (exp -> NUMBER .)
    ]               reduce using rule 39 (exp -> NUMBER .)
    }               reduce using rule 39 (exp -> NUMBER .)


state 34

    (40) exp -> STRING .
    ,               reduce using rule 40 (exp -> STRING .)
    ^               reduce using rule 40 (exp -> STRING .)
    %               reduce using rule 40 (exp -> STRING .)
    /               reduce using rule 40 (exp -> STRING .)
    *               reduce using rule 40 (exp -> STRING .)
    -               reduce using rule 40 (exp -> STRING .)
    +               reduce using rule 40 (exp -> STRING .)
    CONCAT          reduce using rule 40 (exp -> STRING .)
    NE              reduce using rule 40 (exp -> STRING .)
    EQ              reduce using rule 40 (exp -> STRING .)
    GE              reduce using rule 40 (exp -> STRING .)
    GT              reduce using rule 40 (exp -> STRING .)
    LE              reduce using rule 40 (exp -> STRING .)
    LT              reduce using rule 40 (exp -> STRING .)
    AND             reduce using rule 40 (exp -> STRING .)
    OR              reduce using rule 40 (exp -> STRING .)
    ;               reduce using rule 40 (exp -> STRING .)
    THEN            reduce using rule 40 (exp -> STRING .)
    DO              reduce using rule 40 (exp -> STRING .)
    )               reduce using rule 40 (exp -> STRING .)
    ]               reduce using rule 40 (exp -> STRING .)
    }               reduce using rule 40 (exp -> STRING .)


state 35

    (41) exp -> FALSE .
    ,               reduce using rule 41 (exp -> FALSE .)
    ^               reduce using rule 41 (exp -> FALSE .)
    %               reduce using rule 41 (exp -> FALSE .)
    /               reduce using rule 41 (exp -> FALSE .)
    *               reduce using rule 41 (exp -> FALSE .)
    -               reduce using rule 41 (exp -> FALSE .)
    +               reduce using rule 41 (exp -> FALSE .)
    CONCAT          reduce using rule 41 (exp -> FALSE .)
    NE              reduce using rule 41 (exp -> FALSE .)
    EQ              reduce using rule 41 (exp -> FALSE .)
    GE              reduce using rule 41 (exp -> FALSE .)
    GT              reduce using rule 41 (exp -> FALSE .)
    LE              reduce using rule 41 (exp -> FALSE .)
    LT              reduce using rule 41 (exp -> FALSE .)
    AND             reduce using rule 41 (exp -> FALSE .)
    OR              reduce using rule 41 (exp -> FALSE .)
    ;               reduce using rule 41 (exp -> FALSE .)
    THEN            reduce using rule 41 (exp -> FALSE .)
    DO              reduce using rule 41 (exp -> FALSE .)
    )               reduce using rule 41 (exp -> FALSE .)
    ]               reduce using rule 41 (exp -> FALSE .)
    }               reduce using rule 41 (exp -> FALSE .)


state 36

    (42) exp -> TRUE .
    ,               reduce using rule 42 (exp -> TRUE .)
    ^               reduce using rule 42 (exp -> TRUE .)
    %               reduce using rule 42 (exp -> TRUE .)
    /               reduce using rule 42 (exp -> TRUE .)
    *               reduce using rule 42 (exp -> TRUE .)
    -               reduce using rule 42 (exp -> TRUE .)
    +               reduce using rule 42 (exp -> TRUE .)
    CONCAT          reduce using rule 42 (exp -> TRUE .)
    NE              reduce using rule 42 (exp -> TRUE .)
    EQ              reduce using rule 42 (exp -> TRUE .)
    GE              reduce using rule 42 (exp -> TRUE .)
    GT              reduce using rule 42 (exp -> TRUE .)
    LE              reduce using rule 42 (exp -> TRUE .)
    LT              reduce using rule 42 (exp -> TRUE .)
    AND             reduce using rule 42 (exp -> TRUE .)
    OR              reduce using rule 42 (exp -> TRUE .)
    ;               reduce using rule 42 (exp -> TRUE .)
    THEN            reduce using rule 42 (exp -> TRUE .)
    DO              reduce using rule 42 (exp -> TRUE .)
    )               reduce using rule 42 (exp -> TRUE .)
    ]               reduce using rule 42 (exp -> TRUE .)
    }               reduce using rule 42 (exp -> TRUE .)


state 37

    (43) exp -> NIL .
    ,               reduce using rule 43 (exp -> NIL .)
    ^               reduce using rule 43 (exp -> NIL .)
    %               reduce using rule 43 (exp -> NIL .)
    /               reduce using rule 43 (exp -> NIL .)
    *               reduce using rule 43 (exp -> NIL .)
    -               reduce using rule 43 (exp -> NIL .)
    +               reduce using rule 43 (exp -> NIL .)
    CONCAT          reduce using rule 43 (exp -> NIL .)
    NE              reduce using rule 43 (exp -> NIL .)
    EQ              reduce using rule 43 (exp -> NIL .)
    GE              reduce using rule 43 (exp -> NIL .)
    GT              reduce using rule 43 (exp -> NIL .)
    LE              reduce using rule 43 (exp -> NIL .)
    LT              reduce using rule 43 (exp -> NIL .)
    AND             reduce using rule 43 (exp -> NIL .)
    OR              reduce using rule 43 (exp -> NIL .)
    ;               reduce using rule 43 (exp -> NIL .)
    THEN            reduce using rule 43 (exp -> NIL .)
    DO              reduce using rule 43 (exp -> NIL .)
    )               reduce using rule 43 (exp -> NIL .)
    ]               reduce using rule 43 (exp -> NIL .)
    }               reduce using rule 43 (exp -> NIL .)


state 38

    (44) exp -> NOT . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 85
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 39

    (45) exp -> - . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 86
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 40

    (62) prefixexp -> functioncall .
    .               reduce using rule 62 (prefixexp -> functioncall .)
    [               reduce using rule 62 (prefixexp -> functioncall .)
    {               reduce using rule 62 (prefixexp -> functioncall .)
    (               reduce using rule 62 (prefixexp -> functioncall .)
    ,               reduce using rule 62 (prefixexp -> functioncall .)
    ^               reduce using rule 62 (prefixexp -> functioncall .)
    %               reduce using rule 62 (prefixexp -> functioncall .)
    /               reduce using rule 62 (prefixexp -> functioncall .)
    *               reduce using rule 62 (prefixexp -> functioncall .)
    -               reduce using rule 62 (prefixexp -> functioncall .)
    +               reduce using rule 62 (prefixexp -> functioncall .)
    CONCAT          reduce using rule 62 (prefixexp -> functioncall .)
    NE              reduce using rule 62 (prefixexp -> functioncall .)
    EQ              reduce using rule 62 (prefixexp -> functioncall .)
    GE              reduce using rule 62 (prefixexp -> functioncall .)
    GT              reduce using rule 62 (prefixexp -> functioncall .)
    LE              reduce using rule 62 (prefixexp -> functioncall .)
    LT              reduce using rule 62 (prefixexp -> functioncall .)
    AND             reduce using rule 62 (prefixexp -> functioncall .)
    OR              reduce using rule 62 (prefixexp -> functioncall .)
    ;               reduce using rule 62 (prefixexp -> functioncall .)
    THEN            reduce using rule 62 (prefixexp -> functioncall .)
    DO              reduce using rule 62 (prefixexp -> functioncall .)
    )               reduce using rule 62 (prefixexp -> functioncall .)
    ]               reduce using rule 62 (prefixexp -> functioncall .)
    }               reduce using rule 62 (prefixexp -> functioncall .)


state 41

    (65) prefixexp -> NAME .
    .               reduce using rule 65 (prefixexp -> NAME .)
    [               reduce using rule 65 (prefixexp -> NAME .)
    {               reduce using rule 65 (prefixexp -> NAME .)
    (               reduce using rule 65 (prefixexp -> NAME .)
    ,               reduce using rule 65 (prefixexp -> NAME .)
    ^               reduce using rule 65 (prefixexp -> NAME .)
    %               reduce using rule 65 (prefixexp -> NAME .)
    /               reduce using rule 65 (prefixexp -> NAME .)
    *               reduce using rule 65 (prefixexp -> NAME .)
    -               reduce using rule 65 (prefixexp -> NAME .)
    +               reduce using rule 65 (prefixexp -> NAME .)
    CONCAT          reduce using rule 65 (prefixexp -> NAME .)
    NE              reduce using rule 65 (prefixexp -> NAME .)
    EQ              reduce using rule 65 (prefixexp -> NAME .)
    GE              reduce using rule 65 (prefixexp -> NAME .)
    GT              reduce using rule 65 (prefixexp -> NAME .)
    LE              reduce using rule 65 (prefixexp -> NAME .)
    LT              reduce using rule 65 (prefixexp -> NAME .)
    AND             reduce using rule 65 (prefixexp -> NAME .)
    OR              reduce using rule 65 (prefixexp -> NAME .)
    ;               reduce using rule 65 (prefixexp -> NAME .)
    THEN            reduce using rule 65 (prefixexp -> NAME .)
    DO              reduce using rule 65 (prefixexp -> NAME .)
    )               reduce using rule 65 (prefixexp -> NAME .)
    ]               reduce using rule 65 (prefixexp -> NAME .)
    }               reduce using rule 65 (prefixexp -> NAME .)


state 42

    (14) stmt -> IF exp . THEN stmtlist elsepart END
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    THEN            shift and go to state 87
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 43

    (15) stmt -> WHILE exp . DO stmtlist END
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    DO              shift and go to state 88
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 44

    (18) stmt -> varlist = . explist
    (34) explist -> . exp , explist
    (35) explist -> . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    explist                        shift and go to state 89
    exp                            shift and go to state 29
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 45

    (66) functioncall -> prefixexp . . NAME args
    (63) prefixexp -> prefixexp . . NAME
    (31) var -> prefixexp . . NAME
    NAME            shift and go to state 90


state 46

    (67) functioncall -> prefixexp args .
    ;               reduce using rule 67 (functioncall -> prefixexp args .)
    .               reduce using rule 67 (functioncall -> prefixexp args .)
    [               reduce using rule 67 (functioncall -> prefixexp args .)
    {               reduce using rule 67 (functioncall -> prefixexp args .)
    (               reduce using rule 67 (functioncall -> prefixexp args .)
    ,               reduce using rule 67 (functioncall -> prefixexp args .)
    ^               reduce using rule 67 (functioncall -> prefixexp args .)
    %               reduce using rule 67 (functioncall -> prefixexp args .)
    /               reduce using rule 67 (functioncall -> prefixexp args .)
    *               reduce using rule 67 (functioncall -> prefixexp args .)
    -               reduce using rule 67 (functioncall -> prefixexp args .)
    +               reduce using rule 67 (functioncall -> prefixexp args .)
    CONCAT          reduce using rule 67 (functioncall -> prefixexp args .)
    NE              reduce using rule 67 (functioncall -> prefixexp args .)
    EQ              reduce using rule 67 (functioncall -> prefixexp args .)
    GE              reduce using rule 67 (functioncall -> prefixexp args .)
    GT              reduce using rule 67 (functioncall -> prefixexp args .)
    LE              reduce using rule 67 (functioncall -> prefixexp args .)
    LT              reduce using rule 67 (functioncall -> prefixexp args .)
    AND             reduce using rule 67 (functioncall -> prefixexp args .)
    OR              reduce using rule 67 (functioncall -> prefixexp args .)
    THEN            reduce using rule 67 (functioncall -> prefixexp args .)
    DO              reduce using rule 67 (functioncall -> prefixexp args .)
    )               reduce using rule 67 (functioncall -> prefixexp args .)
    ]               reduce using rule 67 (functioncall -> prefixexp args .)
    }               reduce using rule 67 (functioncall -> prefixexp args .)


state 47

    (64) prefixexp -> prefixexp [ . exp ]
    (32) var -> prefixexp [ . exp ]
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    prefixexp                      shift and go to state 31
    exp                            shift and go to state 91
    functioncall                   shift and go to state 40

state 48

    (68) args -> { . fieldlist }
    (71) fieldlist -> . field , fieldlist
    (72) fieldlist -> . field
    (73) fieldlist -> . empty
    (74) field -> . NAME = exp
    (75) field -> . [ exp ] = exp
    (76) empty -> .
    NAME            shift and go to state 80
    [               shift and go to state 81
    }               reduce using rule 76 (empty -> .)

    fieldlist                      shift and go to state 92
    field                          shift and go to state 78
    empty                          shift and go to state 79

state 49

    (69) args -> ( . explist )
    (70) args -> ( . )
    (34) explist -> . exp , explist
    (35) explist -> . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    )               shift and go to state 94
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    explist                        shift and go to state 93
    exp                            shift and go to state 29
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 50

    (29) varlist -> var , . varlist
    (29) varlist -> . var , varlist
    (30) varlist -> . var
    (31) var -> . prefixexp . NAME
    (32) var -> . prefixexp [ exp ]
    (33) var -> . NAME
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    NAME            shift and go to state 97
    (               shift and go to state 18

    var                            shift and go to state 17
    varlist                        shift and go to state 95
    prefixexp                      shift and go to state 96
    functioncall                   shift and go to state 40

state 51

    (61) prefixexp -> ( exp . )
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    )               shift and go to state 98
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 52

    (4) stmt -> LOCAL namelist = . explist
    (34) explist -> . exp , explist
    (35) explist -> . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    explist                        shift and go to state 99
    exp                            shift and go to state 29
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 53

    (6) stmt -> LOCAL FUNCTION function .
    ;               reduce using rule 6 (stmt -> LOCAL FUNCTION function .)


state 54

    (27) namelist -> NAME , . namelist
    (27) namelist -> . NAME , namelist
    (28) namelist -> . NAME
    NAME            shift and go to state 22

    namelist                       shift and go to state 100

state 55

    (22) function -> NAME : . NAME funcbody
    NAME            shift and go to state 101


state 56

    (23) function -> NAME funcbody .
    ;               reduce using rule 23 (function -> NAME funcbody .)


state 57

    (24) funcbody -> ( . params ) stmtlist END
    (25) params -> . namelist
    (26) params -> . empty
    (27) namelist -> . NAME , namelist
    (28) namelist -> . NAME
    (76) empty -> .
    NAME            shift and go to state 22
    )               reduce using rule 76 (empty -> .)

    params                         shift and go to state 102
    namelist                       shift and go to state 103
    empty                          shift and go to state 104

state 58

    (8) stmt -> FOR namelist IN . explist DO stmtlist END
    (34) explist -> . exp , explist
    (35) explist -> . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    explist                        shift and go to state 105
    exp                            shift and go to state 29
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 59

    (9) stmt -> FOR NAME = . exp , exp , exp DO stmtlist END
    (10) stmt -> FOR NAME = . exp , exp DO stmtlist END
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 106
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 60

    (16) stmt -> DO stmtlist END .
    ;               reduce using rule 16 (stmt -> DO stmtlist END .)


state 61

    (34) explist -> exp , . explist
    (34) explist -> . exp , explist
    (35) explist -> . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 29
    explist                        shift and go to state 107
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 62

    (46) exp -> exp ^ . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 108
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 63

    (47) exp -> exp % . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 109
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 64

    (48) exp -> exp / . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 110
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 65

    (49) exp -> exp * . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 111
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 66

    (50) exp -> exp - . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 112
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 67

    (51) exp -> exp + . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 113
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 68

    (52) exp -> exp CONCAT . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 114
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 69

    (53) exp -> exp NE . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 115
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 70

    (54) exp -> exp EQ . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 116
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 71

    (55) exp -> exp GE . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 117
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 72

    (56) exp -> exp GT . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 118
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 73

    (57) exp -> exp LE . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 119
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 74

    (58) exp -> exp LT . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 120
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 75

    (59) exp -> exp AND . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 121
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 76

    (60) exp -> exp OR . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 122
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 77

    (36) exp -> { fieldlist . }
    }               shift and go to state 123


state 78

    (71) fieldlist -> field . , fieldlist
    (72) fieldlist -> field .
    ,               shift and go to state 124
    }               reduce using rule 72 (fieldlist -> field .)


state 79

    (73) fieldlist -> empty .
    }               reduce using rule 73 (fieldlist -> empty .)


state 80

    (74) field -> NAME . = exp
    =               shift and go to state 125


state 81

    (75) field -> [ . exp ] = exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 126
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 82

    (63) prefixexp -> prefixexp . . NAME
    (66) functioncall -> prefixexp . . NAME args
    NAME            shift and go to state 127


state 83

    (64) prefixexp -> prefixexp [ . exp ]
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    prefixexp                      shift and go to state 31
    exp                            shift and go to state 128
    functioncall                   shift and go to state 40

state 84

    (38) exp -> FUNCTION funcbody .
    ,               reduce using rule 38 (exp -> FUNCTION funcbody .)
    ^               reduce using rule 38 (exp -> FUNCTION funcbody .)
    %               reduce using rule 38 (exp -> FUNCTION funcbody .)
    /               reduce using rule 38 (exp -> FUNCTION funcbody .)
    *               reduce using rule 38 (exp -> FUNCTION funcbody .)
    -               reduce using rule 38 (exp -> FUNCTION funcbody .)
    +               reduce using rule 38 (exp -> FUNCTION funcbody .)
    CONCAT          reduce using rule 38 (exp -> FUNCTION funcbody .)
    NE              reduce using rule 38 (exp -> FUNCTION funcbody .)
    EQ              reduce using rule 38 (exp -> FUNCTION funcbody .)
    GE              reduce using rule 38 (exp -> FUNCTION funcbody .)
    GT              reduce using rule 38 (exp -> FUNCTION funcbody .)
    LE              reduce using rule 38 (exp -> FUNCTION funcbody .)
    LT              reduce using rule 38 (exp -> FUNCTION funcbody .)
    AND             reduce using rule 38 (exp -> FUNCTION funcbody .)
    OR              reduce using rule 38 (exp -> FUNCTION funcbody .)
    ;               reduce using rule 38 (exp -> FUNCTION funcbody .)
    THEN            reduce using rule 38 (exp -> FUNCTION funcbody .)
    DO              reduce using rule 38 (exp -> FUNCTION funcbody .)
    )               reduce using rule 38 (exp -> FUNCTION funcbody .)
    ]               reduce using rule 38 (exp -> FUNCTION funcbody .)
    }               reduce using rule 38 (exp -> FUNCTION funcbody .)


state 85

    (44) exp -> NOT exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 44 (exp -> NOT exp .)
    %               reduce using rule 44 (exp -> NOT exp .)
    /               reduce using rule 44 (exp -> NOT exp .)
    *               reduce using rule 44 (exp -> NOT exp .)
    -               reduce using rule 44 (exp -> NOT exp .)
    +               reduce using rule 44 (exp -> NOT exp .)
    NE              reduce using rule 44 (exp -> NOT exp .)
    EQ              reduce using rule 44 (exp -> NOT exp .)
    GE              reduce using rule 44 (exp -> NOT exp .)
    GT              reduce using rule 44 (exp -> NOT exp .)
    LE              reduce using rule 44 (exp -> NOT exp .)
    LT              reduce using rule 44 (exp -> NOT exp .)
    AND             reduce using rule 44 (exp -> NOT exp .)
    OR              reduce using rule 44 (exp -> NOT exp .)
    ;               reduce using rule 44 (exp -> NOT exp .)
    THEN            reduce using rule 44 (exp -> NOT exp .)
    DO              reduce using rule 44 (exp -> NOT exp .)
    )               reduce using rule 44 (exp -> NOT exp .)
    ]               reduce using rule 44 (exp -> NOT exp .)
    }               reduce using rule 44 (exp -> NOT exp .)
    ^               shift and go to state 62
    CONCAT          shift and go to state 68


state 86

    (45) exp -> - exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 45 (exp -> - exp .)
    %               reduce using rule 45 (exp -> - exp .)
    /               reduce using rule 45 (exp -> - exp .)
    *               reduce using rule 45 (exp -> - exp .)
    -               reduce using rule 45 (exp -> - exp .)
    +               reduce using rule 45 (exp -> - exp .)
    NE              reduce using rule 45 (exp -> - exp .)
    EQ              reduce using rule 45 (exp -> - exp .)
    GE              reduce using rule 45 (exp -> - exp .)
    GT              reduce using rule 45 (exp -> - exp .)
    LE              reduce using rule 45 (exp -> - exp .)
    LT              reduce using rule 45 (exp -> - exp .)
    AND             reduce using rule 45 (exp -> - exp .)
    OR              reduce using rule 45 (exp -> - exp .)
    ;               reduce using rule 45 (exp -> - exp .)
    THEN            reduce using rule 45 (exp -> - exp .)
    DO              reduce using rule 45 (exp -> - exp .)
    )               reduce using rule 45 (exp -> - exp .)
    ]               reduce using rule 45 (exp -> - exp .)
    }               reduce using rule 45 (exp -> - exp .)
    ^               shift and go to state 62
    CONCAT          shift and go to state 68


state 87

    (14) stmt -> IF exp THEN . stmtlist elsepart END
    (2) stmtlist -> . stmtlist stmt ;
    (3) stmtlist -> . empty
    (76) empty -> .
    ELSEIF          reduce using rule 76 (empty -> .)
    ELSE            reduce using rule 76 (empty -> .)
    LOCAL           reduce using rule 76 (empty -> .)
    FUNCTION        reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    BREAK           reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    DO              reduce using rule 76 (empty -> .)
    (               reduce using rule 76 (empty -> .)
    NAME            reduce using rule 76 (empty -> .)
    END             reduce using rule 76 (empty -> .)

    stmtlist                       shift and go to state 129
    empty                          shift and go to state 3

state 88

    (15) stmt -> WHILE exp DO . stmtlist END
    (2) stmtlist -> . stmtlist stmt ;
    (3) stmtlist -> . empty
    (76) empty -> .
    END             reduce using rule 76 (empty -> .)
    LOCAL           reduce using rule 76 (empty -> .)
    FUNCTION        reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    BREAK           reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    DO              reduce using rule 76 (empty -> .)
    (               reduce using rule 76 (empty -> .)
    NAME            reduce using rule 76 (empty -> .)

    stmtlist                       shift and go to state 130
    empty                          shift and go to state 3

state 89

    (18) stmt -> varlist = explist .
    ;               reduce using rule 18 (stmt -> varlist = explist .)


state 90

    (66) functioncall -> prefixexp . NAME . args
    (63) prefixexp -> prefixexp . NAME .
    (31) var -> prefixexp . NAME .
    (68) args -> . { fieldlist }
    (69) args -> . ( explist )
    (70) args -> . ( )
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    .               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    [               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    ,               reduce using rule 31 (var -> prefixexp . NAME .)
    =               reduce using rule 31 (var -> prefixexp . NAME .)
    {               shift and go to state 48
    (               shift and go to state 49

    args                           shift and go to state 131

state 91

    (64) prefixexp -> prefixexp [ exp . ]
    (32) var -> prefixexp [ exp . ]
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ]               shift and go to state 132
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 92

    (68) args -> { fieldlist . }
    }               shift and go to state 133


state 93

    (69) args -> ( explist . )
    )               shift and go to state 134


state 94

    (70) args -> ( ) .
    ;               reduce using rule 70 (args -> ( ) .)
    .               reduce using rule 70 (args -> ( ) .)
    [               reduce using rule 70 (args -> ( ) .)
    {               reduce using rule 70 (args -> ( ) .)
    (               reduce using rule 70 (args -> ( ) .)
    ,               reduce using rule 70 (args -> ( ) .)
    ^               reduce using rule 70 (args -> ( ) .)
    %               reduce using rule 70 (args -> ( ) .)
    /               reduce using rule 70 (args -> ( ) .)
    *               reduce using rule 70 (args -> ( ) .)
    -               reduce using rule 70 (args -> ( ) .)
    +               reduce using rule 70 (args -> ( ) .)
    CONCAT          reduce using rule 70 (args -> ( ) .)
    NE              reduce using rule 70 (args -> ( ) .)
    EQ              reduce using rule 70 (args -> ( ) .)
    GE              reduce using rule 70 (args -> ( ) .)
    GT              reduce using rule 70 (args -> ( ) .)
    LE              reduce using rule 70 (args -> ( ) .)
    LT              reduce using rule 70 (args -> ( ) .)
    AND             reduce using rule 70 (args -> ( ) .)
    OR              reduce using rule 70 (args -> ( ) .)
    THEN            reduce using rule 70 (args -> ( ) .)
    DO              reduce using rule 70 (args -> ( ) .)
    )               reduce using rule 70 (args -> ( ) .)
    ]               reduce using rule 70 (args -> ( ) .)
    }               reduce using rule 70 (args -> ( ) .)


state 95

    (29) varlist -> var , varlist .
    =               reduce using rule 29 (varlist -> var , varlist .)


state 96

    (31) var -> prefixexp . . NAME
    (32) var -> prefixexp . [ exp ]
    (63) prefixexp -> prefixexp . . NAME
    (64) prefixexp -> prefixexp . [ exp ]
    (66) functioncall -> prefixexp . . NAME args
    (67) functioncall -> prefixexp . args
    (68) args -> . { fieldlist }
    (69) args -> . ( explist )
    (70) args -> . ( )
    .               shift and go to state 135
    [               shift and go to state 136
    {               shift and go to state 48
    (               shift and go to state 49

    args                           shift and go to state 46

state 97

    (33) var -> NAME .
    (65) prefixexp -> NAME .
    ,               reduce using rule 33 (var -> NAME .)
    =               reduce using rule 33 (var -> NAME .)
    .               reduce using rule 65 (prefixexp -> NAME .)
    [               reduce using rule 65 (prefixexp -> NAME .)
    {               reduce using rule 65 (prefixexp -> NAME .)
    (               reduce using rule 65 (prefixexp -> NAME .)


state 98

    (61) prefixexp -> ( exp ) .
    .               reduce using rule 61 (prefixexp -> ( exp ) .)
    [               reduce using rule 61 (prefixexp -> ( exp ) .)
    {               reduce using rule 61 (prefixexp -> ( exp ) .)
    (               reduce using rule 61 (prefixexp -> ( exp ) .)
    ,               reduce using rule 61 (prefixexp -> ( exp ) .)
    ^               reduce using rule 61 (prefixexp -> ( exp ) .)
    %               reduce using rule 61 (prefixexp -> ( exp ) .)
    /               reduce using rule 61 (prefixexp -> ( exp ) .)
    *               reduce using rule 61 (prefixexp -> ( exp ) .)
    -               reduce using rule 61 (prefixexp -> ( exp ) .)
    +               reduce using rule 61 (prefixexp -> ( exp ) .)
    CONCAT          reduce using rule 61 (prefixexp -> ( exp ) .)
    NE              reduce using rule 61 (prefixexp -> ( exp ) .)
    EQ              reduce using rule 61 (prefixexp -> ( exp ) .)
    GE              reduce using rule 61 (prefixexp -> ( exp ) .)
    GT              reduce using rule 61 (prefixexp -> ( exp ) .)
    LE              reduce using rule 61 (prefixexp -> ( exp ) .)
    LT              reduce using rule 61 (prefixexp -> ( exp ) .)
    AND             reduce using rule 61 (prefixexp -> ( exp ) .)
    OR              reduce using rule 61 (prefixexp -> ( exp ) .)
    ;               reduce using rule 61 (prefixexp -> ( exp ) .)
    THEN            reduce using rule 61 (prefixexp -> ( exp ) .)
    DO              reduce using rule 61 (prefixexp -> ( exp ) .)
    )               reduce using rule 61 (prefixexp -> ( exp ) .)
    ]               reduce using rule 61 (prefixexp -> ( exp ) .)
    }               reduce using rule 61 (prefixexp -> ( exp ) .)


state 99

    (4) stmt -> LOCAL namelist = explist .
    ;               reduce using rule 4 (stmt -> LOCAL namelist = explist .)


state 100

    (27) namelist -> NAME , namelist .
    =               reduce using rule 27 (namelist -> NAME , namelist .)
    ;               reduce using rule 27 (namelist -> NAME , namelist .)
    IN              reduce using rule 27 (namelist -> NAME , namelist .)
    )               reduce using rule 27 (namelist -> NAME , namelist .)


state 101

    (22) function -> NAME : NAME . funcbody
    (24) funcbody -> . ( params ) stmtlist END
    (               shift and go to state 57

    funcbody                       shift and go to state 137

state 102

    (24) funcbody -> ( params . ) stmtlist END
    )               shift and go to state 138


state 103

    (25) params -> namelist .
    )               reduce using rule 25 (params -> namelist .)


state 104

    (26) params -> empty .
    )               reduce using rule 26 (params -> empty .)


state 105

    (8) stmt -> FOR namelist IN explist . DO stmtlist END
    DO              shift and go to state 139


state 106

    (9) stmt -> FOR NAME = exp . , exp , exp DO stmtlist END
    (10) stmt -> FOR NAME = exp . , exp DO stmtlist END
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               shift and go to state 140
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 107

    (34) explist -> exp , explist .
    ;               reduce using rule 34 (explist -> exp , explist .)
    )               reduce using rule 34 (explist -> exp , explist .)
    DO              reduce using rule 34 (explist -> exp , explist .)


state 108

    (46) exp -> exp ^ exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 46 (exp -> exp ^ exp .)
    %               reduce using rule 46 (exp -> exp ^ exp .)
    /               reduce using rule 46 (exp -> exp ^ exp .)
    *               reduce using rule 46 (exp -> exp ^ exp .)
    -               reduce using rule 46 (exp -> exp ^ exp .)
    +               reduce using rule 46 (exp -> exp ^ exp .)
    CONCAT          reduce using rule 46 (exp -> exp ^ exp .)
    NE              reduce using rule 46 (exp -> exp ^ exp .)
    EQ              reduce using rule 46 (exp -> exp ^ exp .)
    GE              reduce using rule 46 (exp -> exp ^ exp .)
    GT              reduce using rule 46 (exp -> exp ^ exp .)
    LE              reduce using rule 46 (exp -> exp ^ exp .)
    LT              reduce using rule 46 (exp -> exp ^ exp .)
    AND             reduce using rule 46 (exp -> exp ^ exp .)
    OR              reduce using rule 46 (exp -> exp ^ exp .)
    ;               reduce using rule 46 (exp -> exp ^ exp .)
    THEN            reduce using rule 46 (exp -> exp ^ exp .)
    DO              reduce using rule 46 (exp -> exp ^ exp .)
    )               reduce using rule 46 (exp -> exp ^ exp .)
    ]               reduce using rule 46 (exp -> exp ^ exp .)
    }               reduce using rule 46 (exp -> exp ^ exp .)
    ^               shift and go to state 62


state 109

    (47) exp -> exp % exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 47 (exp -> exp % exp .)
    %               reduce using rule 47 (exp -> exp % exp .)
    /               reduce using rule 47 (exp -> exp % exp .)
    *               reduce using rule 47 (exp -> exp % exp .)
    -               reduce using rule 47 (exp -> exp % exp .)
    +               reduce using rule 47 (exp -> exp % exp .)
    NE              reduce using rule 47 (exp -> exp % exp .)
    EQ              reduce using rule 47 (exp -> exp % exp .)
    GE              reduce using rule 47 (exp -> exp % exp .)
    GT              reduce using rule 47 (exp -> exp % exp .)
    LE              reduce using rule 47 (exp -> exp % exp .)
    LT              reduce using rule 47 (exp -> exp % exp .)
    AND             reduce using rule 47 (exp -> exp % exp .)
    OR              reduce using rule 47 (exp -> exp % exp .)
    ;               reduce using rule 47 (exp -> exp % exp .)
    THEN            reduce using rule 47 (exp -> exp % exp .)
    DO              reduce using rule 47 (exp -> exp % exp .)
    )               reduce using rule 47 (exp -> exp % exp .)
    ]               reduce using rule 47 (exp -> exp % exp .)
    }               reduce using rule 47 (exp -> exp % exp .)
    ^               shift and go to state 62
    CONCAT          shift and go to state 68


state 110

    (48) exp -> exp / exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 48 (exp -> exp / exp .)
    %               reduce using rule 48 (exp -> exp / exp .)
    /               reduce using rule 48 (exp -> exp / exp .)
    *               reduce using rule 48 (exp -> exp / exp .)
    -               reduce using rule 48 (exp -> exp / exp .)
    +               reduce using rule 48 (exp -> exp / exp .)
    NE              reduce using rule 48 (exp -> exp / exp .)
    EQ              reduce using rule 48 (exp -> exp / exp .)
    GE              reduce using rule 48 (exp -> exp / exp .)
    GT              reduce using rule 48 (exp -> exp / exp .)
    LE              reduce using rule 48 (exp -> exp / exp .)
    LT              reduce using rule 48 (exp -> exp / exp .)
    AND             reduce using rule 48 (exp -> exp / exp .)
    OR              reduce using rule 48 (exp -> exp / exp .)
    ;               reduce using rule 48 (exp -> exp / exp .)
    THEN            reduce using rule 48 (exp -> exp / exp .)
    DO              reduce using rule 48 (exp -> exp / exp .)
    )               reduce using rule 48 (exp -> exp / exp .)
    ]               reduce using rule 48 (exp -> exp / exp .)
    }               reduce using rule 48 (exp -> exp / exp .)
    ^               shift and go to state 62
    CONCAT          shift and go to state 68


state 111

    (49) exp -> exp * exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 49 (exp -> exp * exp .)
    %               reduce using rule 49 (exp -> exp * exp .)
    /               reduce using rule 49 (exp -> exp * exp .)
    *               reduce using rule 49 (exp -> exp * exp .)
    -               reduce using rule 49 (exp -> exp * exp .)
    +               reduce using rule 49 (exp -> exp * exp .)
    NE              reduce using rule 49 (exp -> exp * exp .)
    EQ              reduce using rule 49 (exp -> exp * exp .)
    GE              reduce using rule 49 (exp -> exp * exp .)
    GT              reduce using rule 49 (exp -> exp * exp .)
    LE              reduce using rule 49 (exp -> exp * exp .)
    LT              reduce using rule 49 (exp -> exp * exp .)
    AND             reduce using rule 49 (exp -> exp * exp .)
    OR              reduce using rule 49 (exp -> exp * exp .)
    ;               reduce using rule 49 (exp -> exp * exp .)
    THEN            reduce using rule 49 (exp -> exp * exp .)
    DO              reduce using rule 49 (exp -> exp * exp .)
    )               reduce using rule 49 (exp -> exp * exp .)
    ]               reduce using rule 49 (exp -> exp * exp .)
    }               reduce using rule 49 (exp -> exp * exp .)
    ^               shift and go to state 62
    CONCAT          shift and go to state 68


state 112

    (50) exp -> exp - exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 50 (exp -> exp - exp .)
    -               reduce using rule 50 (exp -> exp - exp .)
    +               reduce using rule 50 (exp -> exp - exp .)
    NE              reduce using rule 50 (exp -> exp - exp .)
    EQ              reduce using rule 50 (exp -> exp - exp .)
    GE              reduce using rule 50 (exp -> exp - exp .)
    GT              reduce using rule 50 (exp -> exp - exp .)
    LE              reduce using rule 50 (exp -> exp - exp .)
    LT              reduce using rule 50 (exp -> exp - exp .)
    AND             reduce using rule 50 (exp -> exp - exp .)
    OR              reduce using rule 50 (exp -> exp - exp .)
    ;               reduce using rule 50 (exp -> exp - exp .)
    THEN            reduce using rule 50 (exp -> exp - exp .)
    DO              reduce using rule 50 (exp -> exp - exp .)
    )               reduce using rule 50 (exp -> exp - exp .)
    ]               reduce using rule 50 (exp -> exp - exp .)
    }               reduce using rule 50 (exp -> exp - exp .)
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    CONCAT          shift and go to state 68


state 113

    (51) exp -> exp + exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 51 (exp -> exp + exp .)
    -               reduce using rule 51 (exp -> exp + exp .)
    +               reduce using rule 51 (exp -> exp + exp .)
    NE              reduce using rule 51 (exp -> exp + exp .)
    EQ              reduce using rule 51 (exp -> exp + exp .)
    GE              reduce using rule 51 (exp -> exp + exp .)
    GT              reduce using rule 51 (exp -> exp + exp .)
    LE              reduce using rule 51 (exp -> exp + exp .)
    LT              reduce using rule 51 (exp -> exp + exp .)
    AND             reduce using rule 51 (exp -> exp + exp .)
    OR              reduce using rule 51 (exp -> exp + exp .)
    ;               reduce using rule 51 (exp -> exp + exp .)
    THEN            reduce using rule 51 (exp -> exp + exp .)
    DO              reduce using rule 51 (exp -> exp + exp .)
    )               reduce using rule 51 (exp -> exp + exp .)
    ]               reduce using rule 51 (exp -> exp + exp .)
    }               reduce using rule 51 (exp -> exp + exp .)
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    CONCAT          shift and go to state 68


state 114

    (52) exp -> exp CONCAT exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 52 (exp -> exp CONCAT exp .)
    %               reduce using rule 52 (exp -> exp CONCAT exp .)
    /               reduce using rule 52 (exp -> exp CONCAT exp .)
    *               reduce using rule 52 (exp -> exp CONCAT exp .)
    -               reduce using rule 52 (exp -> exp CONCAT exp .)
    +               reduce using rule 52 (exp -> exp CONCAT exp .)
    NE              reduce using rule 52 (exp -> exp CONCAT exp .)
    EQ              reduce using rule 52 (exp -> exp CONCAT exp .)
    GE              reduce using rule 52 (exp -> exp CONCAT exp .)
    GT              reduce using rule 52 (exp -> exp CONCAT exp .)
    LE              reduce using rule 52 (exp -> exp CONCAT exp .)
    LT              reduce using rule 52 (exp -> exp CONCAT exp .)
    AND             reduce using rule 52 (exp -> exp CONCAT exp .)
    OR              reduce using rule 52 (exp -> exp CONCAT exp .)
    ;               reduce using rule 52 (exp -> exp CONCAT exp .)
    THEN            reduce using rule 52 (exp -> exp CONCAT exp .)
    DO              reduce using rule 52 (exp -> exp CONCAT exp .)
    )               reduce using rule 52 (exp -> exp CONCAT exp .)
    ]               reduce using rule 52 (exp -> exp CONCAT exp .)
    }               reduce using rule 52 (exp -> exp CONCAT exp .)
    ^               shift and go to state 62
    CONCAT          shift and go to state 68


state 115

    (53) exp -> exp NE exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 53 (exp -> exp NE exp .)
    NE              reduce using rule 53 (exp -> exp NE exp .)
    EQ              reduce using rule 53 (exp -> exp NE exp .)
    GE              reduce using rule 53 (exp -> exp NE exp .)
    GT              reduce using rule 53 (exp -> exp NE exp .)
    LE              reduce using rule 53 (exp -> exp NE exp .)
    LT              reduce using rule 53 (exp -> exp NE exp .)
    AND             reduce using rule 53 (exp -> exp NE exp .)
    OR              reduce using rule 53 (exp -> exp NE exp .)
    ;               reduce using rule 53 (exp -> exp NE exp .)
    THEN            reduce using rule 53 (exp -> exp NE exp .)
    DO              reduce using rule 53 (exp -> exp NE exp .)
    )               reduce using rule 53 (exp -> exp NE exp .)
    ]               reduce using rule 53 (exp -> exp NE exp .)
    }               reduce using rule 53 (exp -> exp NE exp .)
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68


state 116

    (54) exp -> exp EQ exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 54 (exp -> exp EQ exp .)
    NE              reduce using rule 54 (exp -> exp EQ exp .)
    EQ              reduce using rule 54 (exp -> exp EQ exp .)
    GE              reduce using rule 54 (exp -> exp EQ exp .)
    GT              reduce using rule 54 (exp -> exp EQ exp .)
    LE              reduce using rule 54 (exp -> exp EQ exp .)
    LT              reduce using rule 54 (exp -> exp EQ exp .)
    AND             reduce using rule 54 (exp -> exp EQ exp .)
    OR              reduce using rule 54 (exp -> exp EQ exp .)
    ;               reduce using rule 54 (exp -> exp EQ exp .)
    THEN            reduce using rule 54 (exp -> exp EQ exp .)
    DO              reduce using rule 54 (exp -> exp EQ exp .)
    )               reduce using rule 54 (exp -> exp EQ exp .)
    ]               reduce using rule 54 (exp -> exp EQ exp .)
    }               reduce using rule 54 (exp -> exp EQ exp .)
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68


state 117

    (55) exp -> exp GE exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 55 (exp -> exp GE exp .)
    NE              reduce using rule 55 (exp -> exp GE exp .)
    EQ              reduce using rule 55 (exp -> exp GE exp .)
    GE              reduce using rule 55 (exp -> exp GE exp .)
    GT              reduce using rule 55 (exp -> exp GE exp .)
    LE              reduce using rule 55 (exp -> exp GE exp .)
    LT              reduce using rule 55 (exp -> exp GE exp .)
    AND             reduce using rule 55 (exp -> exp GE exp .)
    OR              reduce using rule 55 (exp -> exp GE exp .)
    ;               reduce using rule 55 (exp -> exp GE exp .)
    THEN            reduce using rule 55 (exp -> exp GE exp .)
    DO              reduce using rule 55 (exp -> exp GE exp .)
    )               reduce using rule 55 (exp -> exp GE exp .)
    ]               reduce using rule 55 (exp -> exp GE exp .)
    }               reduce using rule 55 (exp -> exp GE exp .)
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68


state 118

    (56) exp -> exp GT exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 56 (exp -> exp GT exp .)
    NE              reduce using rule 56 (exp -> exp GT exp .)
    EQ              reduce using rule 56 (exp -> exp GT exp .)
    GE              reduce using rule 56 (exp -> exp GT exp .)
    GT              reduce using rule 56 (exp -> exp GT exp .)
    LE              reduce using rule 56 (exp -> exp GT exp .)
    LT              reduce using rule 56 (exp -> exp GT exp .)
    AND             reduce using rule 56 (exp -> exp GT exp .)
    OR              reduce using rule 56 (exp -> exp GT exp .)
    ;               reduce using rule 56 (exp -> exp GT exp .)
    THEN            reduce using rule 56 (exp -> exp GT exp .)
    DO              reduce using rule 56 (exp -> exp GT exp .)
    )               reduce using rule 56 (exp -> exp GT exp .)
    ]               reduce using rule 56 (exp -> exp GT exp .)
    }               reduce using rule 56 (exp -> exp GT exp .)
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68


state 119

    (57) exp -> exp LE exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 57 (exp -> exp LE exp .)
    NE              reduce using rule 57 (exp -> exp LE exp .)
    EQ              reduce using rule 57 (exp -> exp LE exp .)
    GE              reduce using rule 57 (exp -> exp LE exp .)
    GT              reduce using rule 57 (exp -> exp LE exp .)
    LE              reduce using rule 57 (exp -> exp LE exp .)
    LT              reduce using rule 57 (exp -> exp LE exp .)
    AND             reduce using rule 57 (exp -> exp LE exp .)
    OR              reduce using rule 57 (exp -> exp LE exp .)
    ;               reduce using rule 57 (exp -> exp LE exp .)
    THEN            reduce using rule 57 (exp -> exp LE exp .)
    DO              reduce using rule 57 (exp -> exp LE exp .)
    )               reduce using rule 57 (exp -> exp LE exp .)
    ]               reduce using rule 57 (exp -> exp LE exp .)
    }               reduce using rule 57 (exp -> exp LE exp .)
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68


state 120

    (58) exp -> exp LT exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 58 (exp -> exp LT exp .)
    NE              reduce using rule 58 (exp -> exp LT exp .)
    EQ              reduce using rule 58 (exp -> exp LT exp .)
    GE              reduce using rule 58 (exp -> exp LT exp .)
    GT              reduce using rule 58 (exp -> exp LT exp .)
    LE              reduce using rule 58 (exp -> exp LT exp .)
    LT              reduce using rule 58 (exp -> exp LT exp .)
    AND             reduce using rule 58 (exp -> exp LT exp .)
    OR              reduce using rule 58 (exp -> exp LT exp .)
    ;               reduce using rule 58 (exp -> exp LT exp .)
    THEN            reduce using rule 58 (exp -> exp LT exp .)
    DO              reduce using rule 58 (exp -> exp LT exp .)
    )               reduce using rule 58 (exp -> exp LT exp .)
    ]               reduce using rule 58 (exp -> exp LT exp .)
    }               reduce using rule 58 (exp -> exp LT exp .)
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68


state 121

    (59) exp -> exp AND exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 59 (exp -> exp AND exp .)
    AND             reduce using rule 59 (exp -> exp AND exp .)
    OR              reduce using rule 59 (exp -> exp AND exp .)
    ;               reduce using rule 59 (exp -> exp AND exp .)
    THEN            reduce using rule 59 (exp -> exp AND exp .)
    DO              reduce using rule 59 (exp -> exp AND exp .)
    )               reduce using rule 59 (exp -> exp AND exp .)
    ]               reduce using rule 59 (exp -> exp AND exp .)
    }               reduce using rule 59 (exp -> exp AND exp .)
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74


state 122

    (60) exp -> exp OR exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 60 (exp -> exp OR exp .)
    OR              reduce using rule 60 (exp -> exp OR exp .)
    ;               reduce using rule 60 (exp -> exp OR exp .)
    THEN            reduce using rule 60 (exp -> exp OR exp .)
    DO              reduce using rule 60 (exp -> exp OR exp .)
    )               reduce using rule 60 (exp -> exp OR exp .)
    ]               reduce using rule 60 (exp -> exp OR exp .)
    }               reduce using rule 60 (exp -> exp OR exp .)
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75


state 123

    (36) exp -> { fieldlist } .
    ,               reduce using rule 36 (exp -> { fieldlist } .)
    ^               reduce using rule 36 (exp -> { fieldlist } .)
    %               reduce using rule 36 (exp -> { fieldlist } .)
    /               reduce using rule 36 (exp -> { fieldlist } .)
    *               reduce using rule 36 (exp -> { fieldlist } .)
    -               reduce using rule 36 (exp -> { fieldlist } .)
    +               reduce using rule 36 (exp -> { fieldlist } .)
    CONCAT          reduce using rule 36 (exp -> { fieldlist } .)
    NE              reduce using rule 36 (exp -> { fieldlist } .)
    EQ              reduce using rule 36 (exp -> { fieldlist } .)
    GE              reduce using rule 36 (exp -> { fieldlist } .)
    GT              reduce using rule 36 (exp -> { fieldlist } .)
    LE              reduce using rule 36 (exp -> { fieldlist } .)
    LT              reduce using rule 36 (exp -> { fieldlist } .)
    AND             reduce using rule 36 (exp -> { fieldlist } .)
    OR              reduce using rule 36 (exp -> { fieldlist } .)
    ;               reduce using rule 36 (exp -> { fieldlist } .)
    THEN            reduce using rule 36 (exp -> { fieldlist } .)
    DO              reduce using rule 36 (exp -> { fieldlist } .)
    )               reduce using rule 36 (exp -> { fieldlist } .)
    ]               reduce using rule 36 (exp -> { fieldlist } .)
    }               reduce using rule 36 (exp -> { fieldlist } .)


state 124

    (71) fieldlist -> field , . fieldlist
    (71) fieldlist -> . field , fieldlist
    (72) fieldlist -> . field
    (73) fieldlist -> . empty
    (74) field -> . NAME = exp
    (75) field -> . [ exp ] = exp
    (76) empty -> .
    NAME            shift and go to state 80
    [               shift and go to state 81
    }               reduce using rule 76 (empty -> .)

    field                          shift and go to state 78
    fieldlist                      shift and go to state 141
    empty                          shift and go to state 79

state 125

    (74) field -> NAME = . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 142
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 126

    (75) field -> [ exp . ] = exp
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ]               shift and go to state 143
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 127

    (63) prefixexp -> prefixexp . NAME .
    (66) functioncall -> prefixexp . NAME . args
    (68) args -> . { fieldlist }
    (69) args -> . ( explist )
    (70) args -> . ( )
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    .               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    [               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    ,               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    ^               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    %               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    /               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    *               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    -               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    +               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    CONCAT          reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    NE              reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    EQ              reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    GE              reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    GT              reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    LE              reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    LT              reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    AND             reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    OR              reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    ;               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    THEN            reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    DO              reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    )               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    ]               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    }               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    {               shift and go to state 48
    (               shift and go to state 49

    args                           shift and go to state 131

state 128

    (64) prefixexp -> prefixexp [ exp . ]
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ]               shift and go to state 144
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 129

    (14) stmt -> IF exp THEN stmtlist . elsepart END
    (2) stmtlist -> stmtlist . stmt ;
    (19) elsepart -> . ELSEIF exp THEN stmtlist elsepart
    (20) elsepart -> . ELSE stmtlist
    (21) elsepart -> . empty
    (4) stmt -> . LOCAL namelist = explist
    (5) stmt -> . LOCAL namelist
    (6) stmt -> . LOCAL FUNCTION function
    (7) stmt -> . FUNCTION function
    (8) stmt -> . FOR namelist IN explist DO stmtlist END
    (9) stmt -> . FOR NAME = exp , exp , exp DO stmtlist END
    (10) stmt -> . FOR NAME = exp , exp DO stmtlist END
    (11) stmt -> . BREAK
    (12) stmt -> . RETURN explist
    (13) stmt -> . RETURN
    (14) stmt -> . IF exp THEN stmtlist elsepart END
    (15) stmt -> . WHILE exp DO stmtlist END
    (16) stmt -> . DO stmtlist END
    (17) stmt -> . functioncall
    (18) stmt -> . varlist = explist
    (76) empty -> .
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    (29) varlist -> . var , varlist
    (30) varlist -> . var
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (31) var -> . prefixexp . NAME
    (32) var -> . prefixexp [ exp ]
    (33) var -> . NAME
    ELSEIF          shift and go to state 146
    ELSE            shift and go to state 147
    LOCAL           shift and go to state 5
    FUNCTION        shift and go to state 6
    FOR             shift and go to state 7
    BREAK           shift and go to state 10
    RETURN          shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    DO              shift and go to state 8
    END             reduce using rule 76 (empty -> .)
    (               shift and go to state 18
    NAME            shift and go to state 9

    elsepart                       shift and go to state 145
    stmt                           shift and go to state 4
    empty                          shift and go to state 148
    functioncall                   shift and go to state 14
    varlist                        shift and go to state 15
    prefixexp                      shift and go to state 16
    var                            shift and go to state 17

state 130

    (15) stmt -> WHILE exp DO stmtlist . END
    (2) stmtlist -> stmtlist . stmt ;
    (4) stmt -> . LOCAL namelist = explist
    (5) stmt -> . LOCAL namelist
    (6) stmt -> . LOCAL FUNCTION function
    (7) stmt -> . FUNCTION function
    (8) stmt -> . FOR namelist IN explist DO stmtlist END
    (9) stmt -> . FOR NAME = exp , exp , exp DO stmtlist END
    (10) stmt -> . FOR NAME = exp , exp DO stmtlist END
    (11) stmt -> . BREAK
    (12) stmt -> . RETURN explist
    (13) stmt -> . RETURN
    (14) stmt -> . IF exp THEN stmtlist elsepart END
    (15) stmt -> . WHILE exp DO stmtlist END
    (16) stmt -> . DO stmtlist END
    (17) stmt -> . functioncall
    (18) stmt -> . varlist = explist
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    (29) varlist -> . var , varlist
    (30) varlist -> . var
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (31) var -> . prefixexp . NAME
    (32) var -> . prefixexp [ exp ]
    (33) var -> . NAME
    END             shift and go to state 149
    LOCAL           shift and go to state 5
    FUNCTION        shift and go to state 6
    FOR             shift and go to state 7
    BREAK           shift and go to state 10
    RETURN          shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    DO              shift and go to state 8
    (               shift and go to state 18
    NAME            shift and go to state 9

    stmt                           shift and go to state 4
    functioncall                   shift and go to state 14
    varlist                        shift and go to state 15
    prefixexp                      shift and go to state 16
    var                            shift and go to state 17

state 131

    (66) functioncall -> prefixexp . NAME args .
    ;               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    .               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    [               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    {               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    (               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    ,               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    ^               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    %               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    /               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    *               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    -               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    +               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    CONCAT          reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    NE              reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    EQ              reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    GE              reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    GT              reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    LE              reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    LT              reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    AND             reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    OR              reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    THEN            reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    DO              reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    )               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    ]               reduce using rule 66 (functioncall -> prefixexp . NAME args .)
    }               reduce using rule 66 (functioncall -> prefixexp . NAME args .)


state 132

    (64) prefixexp -> prefixexp [ exp ] .
    (32) var -> prefixexp [ exp ] .
    .               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    [               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    {               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    (               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    ,               reduce using rule 32 (var -> prefixexp [ exp ] .)
    =               reduce using rule 32 (var -> prefixexp [ exp ] .)


state 133

    (68) args -> { fieldlist } .
    ;               reduce using rule 68 (args -> { fieldlist } .)
    .               reduce using rule 68 (args -> { fieldlist } .)
    [               reduce using rule 68 (args -> { fieldlist } .)
    {               reduce using rule 68 (args -> { fieldlist } .)
    (               reduce using rule 68 (args -> { fieldlist } .)
    ,               reduce using rule 68 (args -> { fieldlist } .)
    ^               reduce using rule 68 (args -> { fieldlist } .)
    %               reduce using rule 68 (args -> { fieldlist } .)
    /               reduce using rule 68 (args -> { fieldlist } .)
    *               reduce using rule 68 (args -> { fieldlist } .)
    -               reduce using rule 68 (args -> { fieldlist } .)
    +               reduce using rule 68 (args -> { fieldlist } .)
    CONCAT          reduce using rule 68 (args -> { fieldlist } .)
    NE              reduce using rule 68 (args -> { fieldlist } .)
    EQ              reduce using rule 68 (args -> { fieldlist } .)
    GE              reduce using rule 68 (args -> { fieldlist } .)
    GT              reduce using rule 68 (args -> { fieldlist } .)
    LE              reduce using rule 68 (args -> { fieldlist } .)
    LT              reduce using rule 68 (args -> { fieldlist } .)
    AND             reduce using rule 68 (args -> { fieldlist } .)
    OR              reduce using rule 68 (args -> { fieldlist } .)
    THEN            reduce using rule 68 (args -> { fieldlist } .)
    DO              reduce using rule 68 (args -> { fieldlist } .)
    )               reduce using rule 68 (args -> { fieldlist } .)
    ]               reduce using rule 68 (args -> { fieldlist } .)
    }               reduce using rule 68 (args -> { fieldlist } .)


state 134

    (69) args -> ( explist ) .
    ;               reduce using rule 69 (args -> ( explist ) .)
    .               reduce using rule 69 (args -> ( explist ) .)
    [               reduce using rule 69 (args -> ( explist ) .)
    {               reduce using rule 69 (args -> ( explist ) .)
    (               reduce using rule 69 (args -> ( explist ) .)
    ,               reduce using rule 69 (args -> ( explist ) .)
    ^               reduce using rule 69 (args -> ( explist ) .)
    %               reduce using rule 69 (args -> ( explist ) .)
    /               reduce using rule 69 (args -> ( explist ) .)
    *               reduce using rule 69 (args -> ( explist ) .)
    -               reduce using rule 69 (args -> ( explist ) .)
    +               reduce using rule 69 (args -> ( explist ) .)
    CONCAT          reduce using rule 69 (args -> ( explist ) .)
    NE              reduce using rule 69 (args -> ( explist ) .)
    EQ              reduce using rule 69 (args -> ( explist ) .)
    GE              reduce using rule 69 (args -> ( explist ) .)
    GT              reduce using rule 69 (args -> ( explist ) .)
    LE              reduce using rule 69 (args -> ( explist ) .)
    LT              reduce using rule 69 (args -> ( explist ) .)
    AND             reduce using rule 69 (args -> ( explist ) .)
    OR              reduce using rule 69 (args -> ( explist ) .)
    THEN            reduce using rule 69 (args -> ( explist ) .)
    DO              reduce using rule 69 (args -> ( explist ) .)
    )               reduce using rule 69 (args -> ( explist ) .)
    ]               reduce using rule 69 (args -> ( explist ) .)
    }               reduce using rule 69 (args -> ( explist ) .)


state 135

    (31) var -> prefixexp . . NAME
    (63) prefixexp -> prefixexp . . NAME
    (66) functioncall -> prefixexp . . NAME args
    NAME            shift and go to state 150


state 136

    (32) var -> prefixexp [ . exp ]
    (64) prefixexp -> prefixexp [ . exp ]
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    prefixexp                      shift and go to state 31
    exp                            shift and go to state 151
    functioncall                   shift and go to state 40

state 137

    (22) function -> NAME : NAME funcbody .
    ;               reduce using rule 22 (function -> NAME : NAME funcbody .)


state 138

    (24) funcbody -> ( params ) . stmtlist END
    (2) stmtlist -> . stmtlist stmt ;
    (3) stmtlist -> . empty
    (76) empty -> .
    END             reduce using rule 76 (empty -> .)
    LOCAL           reduce using rule 76 (empty -> .)
    FUNCTION        reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    BREAK           reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    DO              reduce using rule 76 (empty -> .)
    (               reduce using rule 76 (empty -> .)
    NAME            reduce using rule 76 (empty -> .)

    stmtlist                       shift and go to state 152
    empty                          shift and go to state 3

state 139

    (8) stmt -> FOR namelist IN explist DO . stmtlist END
    (2) stmtlist -> . stmtlist stmt ;
    (3) stmtlist -> . empty
    (76) empty -> .
    END             reduce using rule 76 (empty -> .)
    LOCAL           reduce using rule 76 (empty -> .)
    FUNCTION        reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    BREAK           reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    DO              reduce using rule 76 (empty -> .)
    (               reduce using rule 76 (empty -> .)
    NAME            reduce using rule 76 (empty -> .)

    stmtlist                       shift and go to state 153
    empty                          shift and go to state 3

state 140

    (9) stmt -> FOR NAME = exp , . exp , exp DO stmtlist END
    (10) stmt -> FOR NAME = exp , . exp DO stmtlist END
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 154
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 141

    (71) fieldlist -> field , fieldlist .
    }               reduce using rule 71 (fieldlist -> field , fieldlist .)


state 142

    (74) field -> NAME = exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 74 (field -> NAME = exp .)
    }               reduce using rule 74 (field -> NAME = exp .)
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 143

    (75) field -> [ exp ] . = exp
    =               shift and go to state 155


state 144

    (64) prefixexp -> prefixexp [ exp ] .
    .               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    [               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    {               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    (               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    ,               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    ^               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    %               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    /               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    *               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    -               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    +               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    CONCAT          reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    NE              reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    EQ              reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    GE              reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    GT              reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    LE              reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    LT              reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    AND             reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    OR              reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    ;               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    THEN            reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    DO              reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    )               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    ]               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    }               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)


state 145

    (14) stmt -> IF exp THEN stmtlist elsepart . END
    END             shift and go to state 156


state 146

    (19) elsepart -> ELSEIF . exp THEN stmtlist elsepart
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 157
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 147

    (20) elsepart -> ELSE . stmtlist
    (2) stmtlist -> . stmtlist stmt ;
    (3) stmtlist -> . empty
    (76) empty -> .
    LOCAL           reduce using rule 76 (empty -> .)
    FUNCTION        reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    BREAK           reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    DO              reduce using rule 76 (empty -> .)
    (               reduce using rule 76 (empty -> .)
    NAME            reduce using rule 76 (empty -> .)
    END             reduce using rule 76 (empty -> .)

    stmtlist                       shift and go to state 158
    empty                          shift and go to state 3

state 148

    (21) elsepart -> empty .
    END             reduce using rule 21 (elsepart -> empty .)


state 149

    (15) stmt -> WHILE exp DO stmtlist END .
    ;               reduce using rule 15 (stmt -> WHILE exp DO stmtlist END .)


state 150

    (31) var -> prefixexp . NAME .
    (63) prefixexp -> prefixexp . NAME .
    (66) functioncall -> prefixexp . NAME . args
    (68) args -> . { fieldlist }
    (69) args -> . ( explist )
    (70) args -> . ( )
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
    ,               reduce using rule 31 (var -> prefixexp . NAME .)
    =               reduce using rule 31 (var -> prefixexp . NAME .)
    .               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    [               reduce using rule 63 (prefixexp -> prefixexp . NAME .)
    {               shift and go to state 48
    (               shift and go to state 49

    args                           shift and go to state 131

state 151

    (32) var -> prefixexp [ exp . ]
    (64) prefixexp -> prefixexp [ exp . ]
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ]               shift and go to state 159
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 152

    (24) funcbody -> ( params ) stmtlist . END
    (2) stmtlist -> stmtlist . stmt ;
    (4) stmt -> . LOCAL namelist = explist
    (5) stmt -> . LOCAL namelist
    (6) stmt -> . LOCAL FUNCTION function
    (7) stmt -> . FUNCTION function
    (8) stmt -> . FOR namelist IN explist DO stmtlist END
    (9) stmt -> . FOR NAME = exp , exp , exp DO stmtlist END
    (10) stmt -> . FOR NAME = exp , exp DO stmtlist END
    (11) stmt -> . BREAK
    (12) stmt -> . RETURN explist
    (13) stmt -> . RETURN
    (14) stmt -> . IF exp THEN stmtlist elsepart END
    (15) stmt -> . WHILE exp DO stmtlist END
    (16) stmt -> . DO stmtlist END
    (17) stmt -> . functioncall
    (18) stmt -> . varlist = explist
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    (29) varlist -> . var , varlist
    (30) varlist -> . var
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (31) var -> . prefixexp . NAME
    (32) var -> . prefixexp [ exp ]
    (33) var -> . NAME
    END             shift and go to state 160
    LOCAL           shift and go to state 5
    FUNCTION        shift and go to state 6
    FOR             shift and go to state 7
    BREAK           shift and go to state 10
    RETURN          shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    DO              shift and go to state 8
    (               shift and go to state 18
    NAME            shift and go to state 9

    stmt                           shift and go to state 4
    functioncall                   shift and go to state 14
    varlist                        shift and go to state 15
    prefixexp                      shift and go to state 16
    var                            shift and go to state 17

state 153

    (8) stmt -> FOR namelist IN explist DO stmtlist . END
    (2) stmtlist -> stmtlist . stmt ;
    (4) stmt -> . LOCAL namelist = explist
    (5) stmt -> . LOCAL namelist
    (6) stmt -> . LOCAL FUNCTION function
    (7) stmt -> . FUNCTION function
    (8) stmt -> . FOR namelist IN explist DO stmtlist END
    (9) stmt -> . FOR NAME = exp , exp , exp DO stmtlist END
    (10) stmt -> . FOR NAME = exp , exp DO stmtlist END
    (11) stmt -> . BREAK
    (12) stmt -> . RETURN explist
    (13) stmt -> . RETURN
    (14) stmt -> . IF exp THEN stmtlist elsepart END
    (15) stmt -> . WHILE exp DO stmtlist END
    (16) stmt -> . DO stmtlist END
    (17) stmt -> . functioncall
    (18) stmt -> . varlist = explist
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    (29) varlist -> . var , varlist
    (30) varlist -> . var
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (31) var -> . prefixexp . NAME
    (32) var -> . prefixexp [ exp ]
    (33) var -> . NAME
    END             shift and go to state 161
    LOCAL           shift and go to state 5
    FUNCTION        shift and go to state 6
    FOR             shift and go to state 7
    BREAK           shift and go to state 10
    RETURN          shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    DO              shift and go to state 8
    (               shift and go to state 18
    NAME            shift and go to state 9

    stmt                           shift and go to state 4
    functioncall                   shift and go to state 14
    varlist                        shift and go to state 15
    prefixexp                      shift and go to state 16
    var                            shift and go to state 17

state 154

    (9) stmt -> FOR NAME = exp , exp . , exp DO stmtlist END
    (10) stmt -> FOR NAME = exp , exp . DO stmtlist END
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               shift and go to state 162
    DO              shift and go to state 163
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 155

    (75) field -> [ exp ] = . exp
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 164
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 156

    (14) stmt -> IF exp THEN stmtlist elsepart END .
    ;               reduce using rule 14 (stmt -> IF exp THEN stmtlist elsepart END .)


state 157

    (19) elsepart -> ELSEIF exp . THEN stmtlist elsepart
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    THEN            shift and go to state 165
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 158

    (20) elsepart -> ELSE stmtlist .
    (2) stmtlist -> stmtlist . stmt ;
    (4) stmt -> . LOCAL namelist = explist
    (5) stmt -> . LOCAL namelist
    (6) stmt -> . LOCAL FUNCTION function
    (7) stmt -> . FUNCTION function
    (8) stmt -> . FOR namelist IN explist DO stmtlist END
    (9) stmt -> . FOR NAME = exp , exp , exp DO stmtlist END
    (10) stmt -> . FOR NAME = exp , exp DO stmtlist END
    (11) stmt -> . BREAK
    (12) stmt -> . RETURN explist
    (13) stmt -> . RETURN
    (14) stmt -> . IF exp THEN stmtlist elsepart END
    (15) stmt -> . WHILE exp DO stmtlist END
    (16) stmt -> . DO stmtlist END
    (17) stmt -> . functioncall
    (18) stmt -> . varlist = explist
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    (29) varlist -> . var , varlist
    (30) varlist -> . var
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (31) var -> . prefixexp . NAME
    (32) var -> . prefixexp [ exp ]
    (33) var -> . NAME
    END             reduce using rule 20 (elsepart -> ELSE stmtlist .)
    LOCAL           shift and go to state 5
    FUNCTION        shift and go to state 6
    FOR             shift and go to state 7
    BREAK           shift and go to state 10
    RETURN          shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    DO              shift and go to state 8
    (               shift and go to state 18
    NAME            shift and go to state 9

    stmt                           shift and go to state 4
    functioncall                   shift and go to state 14
    varlist                        shift and go to state 15
    prefixexp                      shift and go to state 16
    var                            shift and go to state 17

state 159

    (32) var -> prefixexp [ exp ] .
    (64) prefixexp -> prefixexp [ exp ] .
    ,               reduce using rule 32 (var -> prefixexp [ exp ] .)
    =               reduce using rule 32 (var -> prefixexp [ exp ] .)
    .               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    [               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    {               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)
    (               reduce using rule 64 (prefixexp -> prefixexp [ exp ] .)


state 160

    (24) funcbody -> ( params ) stmtlist END .
    ;               reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    ,               reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    ^               reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    %               reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    /               reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    *               reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    -               reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    +               reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    CONCAT          reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    NE              reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    EQ              reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    GE              reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    GT              reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    LE              reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    LT              reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    AND             reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    OR              reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    THEN            reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    DO              reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    )               reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    ]               reduce using rule 24 (funcbody -> ( params ) stmtlist END .)
    }               reduce using rule 24 (funcbody -> ( params ) stmtlist END .)


state 161

    (8) stmt -> FOR namelist IN explist DO stmtlist END .
    ;               reduce using rule 8 (stmt -> FOR namelist IN explist DO stmtlist END .)


state 162

    (9) stmt -> FOR NAME = exp , exp , . exp DO stmtlist END
    (36) exp -> . { fieldlist }
    (37) exp -> . prefixexp
    (38) exp -> . FUNCTION funcbody
    (39) exp -> . NUMBER
    (40) exp -> . STRING
    (41) exp -> . FALSE
    (42) exp -> . TRUE
    (43) exp -> . NIL
    (44) exp -> . NOT exp
    (45) exp -> . - exp
    (46) exp -> . exp ^ exp
    (47) exp -> . exp % exp
    (48) exp -> . exp / exp
    (49) exp -> . exp * exp
    (50) exp -> . exp - exp
    (51) exp -> . exp + exp
    (52) exp -> . exp CONCAT exp
    (53) exp -> . exp NE exp
    (54) exp -> . exp EQ exp
    (55) exp -> . exp GE exp
    (56) exp -> . exp GT exp
    (57) exp -> . exp LE exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp AND exp
    (60) exp -> . exp OR exp
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    {               shift and go to state 30
    FUNCTION        shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    FALSE           shift and go to state 35
    TRUE            shift and go to state 36
    NIL             shift and go to state 37
    NOT             shift and go to state 38
    -               shift and go to state 39
    (               shift and go to state 18
    NAME            shift and go to state 41

    exp                            shift and go to state 166
    prefixexp                      shift and go to state 31
    functioncall                   shift and go to state 40

state 163

    (10) stmt -> FOR NAME = exp , exp DO . stmtlist END
    (2) stmtlist -> . stmtlist stmt ;
    (3) stmtlist -> . empty
    (76) empty -> .
    END             reduce using rule 76 (empty -> .)
    LOCAL           reduce using rule 76 (empty -> .)
    FUNCTION        reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    BREAK           reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    DO              reduce using rule 76 (empty -> .)
    (               reduce using rule 76 (empty -> .)
    NAME            reduce using rule 76 (empty -> .)

    stmtlist                       shift and go to state 167
    empty                          shift and go to state 3

state 164

    (75) field -> [ exp ] = exp .
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    ,               reduce using rule 75 (field -> [ exp ] = exp .)
    }               reduce using rule 75 (field -> [ exp ] = exp .)
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 165

    (19) elsepart -> ELSEIF exp THEN . stmtlist elsepart
    (2) stmtlist -> . stmtlist stmt ;
    (3) stmtlist -> . empty
    (76) empty -> .
    ELSEIF          reduce using rule 76 (empty -> .)
    ELSE            reduce using rule 76 (empty -> .)
    LOCAL           reduce using rule 76 (empty -> .)
    FUNCTION        reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    BREAK           reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    DO              reduce using rule 76 (empty -> .)
    (               reduce using rule 76 (empty -> .)
    NAME            reduce using rule 76 (empty -> .)
    END             reduce using rule 76 (empty -> .)

    stmtlist                       shift and go to state 168
    empty                          shift and go to state 3

state 166

    (9) stmt -> FOR NAME = exp , exp , exp . DO stmtlist END
    (46) exp -> exp . ^ exp
    (47) exp -> exp . % exp
    (48) exp -> exp . / exp
    (49) exp -> exp . * exp
    (50) exp -> exp . - exp
    (51) exp -> exp . + exp
    (52) exp -> exp . CONCAT exp
    (53) exp -> exp . NE exp
    (54) exp -> exp . EQ exp
    (55) exp -> exp . GE exp
    (56) exp -> exp . GT exp
    (57) exp -> exp . LE exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . AND exp
    (60) exp -> exp . OR exp
    DO              shift and go to state 169
    ^               shift and go to state 62
    %               shift and go to state 63
    /               shift and go to state 64
    *               shift and go to state 65
    -               shift and go to state 66
    +               shift and go to state 67
    CONCAT          shift and go to state 68
    NE              shift and go to state 69
    EQ              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72
    LE              shift and go to state 73
    LT              shift and go to state 74
    AND             shift and go to state 75
    OR              shift and go to state 76


state 167

    (10) stmt -> FOR NAME = exp , exp DO stmtlist . END
    (2) stmtlist -> stmtlist . stmt ;
    (4) stmt -> . LOCAL namelist = explist
    (5) stmt -> . LOCAL namelist
    (6) stmt -> . LOCAL FUNCTION function
    (7) stmt -> . FUNCTION function
    (8) stmt -> . FOR namelist IN explist DO stmtlist END
    (9) stmt -> . FOR NAME = exp , exp , exp DO stmtlist END
    (10) stmt -> . FOR NAME = exp , exp DO stmtlist END
    (11) stmt -> . BREAK
    (12) stmt -> . RETURN explist
    (13) stmt -> . RETURN
    (14) stmt -> . IF exp THEN stmtlist elsepart END
    (15) stmt -> . WHILE exp DO stmtlist END
    (16) stmt -> . DO stmtlist END
    (17) stmt -> . functioncall
    (18) stmt -> . varlist = explist
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    (29) varlist -> . var , varlist
    (30) varlist -> . var
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (31) var -> . prefixexp . NAME
    (32) var -> . prefixexp [ exp ]
    (33) var -> . NAME
    END             shift and go to state 170
    LOCAL           shift and go to state 5
    FUNCTION        shift and go to state 6
    FOR             shift and go to state 7
    BREAK           shift and go to state 10
    RETURN          shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    DO              shift and go to state 8
    (               shift and go to state 18
    NAME            shift and go to state 9

    stmt                           shift and go to state 4
    functioncall                   shift and go to state 14
    varlist                        shift and go to state 15
    prefixexp                      shift and go to state 16
    var                            shift and go to state 17

state 168

    (19) elsepart -> ELSEIF exp THEN stmtlist . elsepart
    (2) stmtlist -> stmtlist . stmt ;
    (19) elsepart -> . ELSEIF exp THEN stmtlist elsepart
    (20) elsepart -> . ELSE stmtlist
    (21) elsepart -> . empty
    (4) stmt -> . LOCAL namelist = explist
    (5) stmt -> . LOCAL namelist
    (6) stmt -> . LOCAL FUNCTION function
    (7) stmt -> . FUNCTION function
    (8) stmt -> . FOR namelist IN explist DO stmtlist END
    (9) stmt -> . FOR NAME = exp , exp , exp DO stmtlist END
    (10) stmt -> . FOR NAME = exp , exp DO stmtlist END
    (11) stmt -> . BREAK
    (12) stmt -> . RETURN explist
    (13) stmt -> . RETURN
    (14) stmt -> . IF exp THEN stmtlist elsepart END
    (15) stmt -> . WHILE exp DO stmtlist END
    (16) stmt -> . DO stmtlist END
    (17) stmt -> . functioncall
    (18) stmt -> . varlist = explist
    (76) empty -> .
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    (29) varlist -> . var , varlist
    (30) varlist -> . var
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (31) var -> . prefixexp . NAME
    (32) var -> . prefixexp [ exp ]
    (33) var -> . NAME
    ELSEIF          shift and go to state 146
    ELSE            shift and go to state 147
    LOCAL           shift and go to state 5
    FUNCTION        shift and go to state 6
    FOR             shift and go to state 7
    BREAK           shift and go to state 10
    RETURN          shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    DO              shift and go to state 8
    END             reduce using rule 76 (empty -> .)
    (               shift and go to state 18
    NAME            shift and go to state 9

    elsepart                       shift and go to state 171
    stmt                           shift and go to state 4
    empty                          shift and go to state 148
    functioncall                   shift and go to state 14
    varlist                        shift and go to state 15
    prefixexp                      shift and go to state 16
    var                            shift and go to state 17

state 169

    (9) stmt -> FOR NAME = exp , exp , exp DO . stmtlist END
    (2) stmtlist -> . stmtlist stmt ;
    (3) stmtlist -> . empty
    (76) empty -> .
    END             reduce using rule 76 (empty -> .)
    LOCAL           reduce using rule 76 (empty -> .)
    FUNCTION        reduce using rule 76 (empty -> .)
    FOR             reduce using rule 76 (empty -> .)
    BREAK           reduce using rule 76 (empty -> .)
    RETURN          reduce using rule 76 (empty -> .)
    IF              reduce using rule 76 (empty -> .)
    WHILE           reduce using rule 76 (empty -> .)
    DO              reduce using rule 76 (empty -> .)
    (               reduce using rule 76 (empty -> .)
    NAME            reduce using rule 76 (empty -> .)

    stmtlist                       shift and go to state 172
    empty                          shift and go to state 3

state 170

    (10) stmt -> FOR NAME = exp , exp DO stmtlist END .
    ;               reduce using rule 10 (stmt -> FOR NAME = exp , exp DO stmtlist END .)


state 171

    (19) elsepart -> ELSEIF exp THEN stmtlist elsepart .
    END             reduce using rule 19 (elsepart -> ELSEIF exp THEN stmtlist elsepart .)


state 172

    (9) stmt -> FOR NAME = exp , exp , exp DO stmtlist . END
    (2) stmtlist -> stmtlist . stmt ;
    (4) stmt -> . LOCAL namelist = explist
    (5) stmt -> . LOCAL namelist
    (6) stmt -> . LOCAL FUNCTION function
    (7) stmt -> . FUNCTION function
    (8) stmt -> . FOR namelist IN explist DO stmtlist END
    (9) stmt -> . FOR NAME = exp , exp , exp DO stmtlist END
    (10) stmt -> . FOR NAME = exp , exp DO stmtlist END
    (11) stmt -> . BREAK
    (12) stmt -> . RETURN explist
    (13) stmt -> . RETURN
    (14) stmt -> . IF exp THEN stmtlist elsepart END
    (15) stmt -> . WHILE exp DO stmtlist END
    (16) stmt -> . DO stmtlist END
    (17) stmt -> . functioncall
    (18) stmt -> . varlist = explist
    (66) functioncall -> . prefixexp . NAME args
    (67) functioncall -> . prefixexp args
    (29) varlist -> . var , varlist
    (30) varlist -> . var
    (61) prefixexp -> . ( exp )
    (62) prefixexp -> . functioncall
    (63) prefixexp -> . prefixexp . NAME
    (64) prefixexp -> . prefixexp [ exp ]
    (65) prefixexp -> . NAME
    (31) var -> . prefixexp . NAME
    (32) var -> . prefixexp [ exp ]
    (33) var -> . NAME
    END             shift and go to state 173
    LOCAL           shift and go to state 5
    FUNCTION        shift and go to state 6
    FOR             shift and go to state 7
    BREAK           shift and go to state 10
    RETURN          shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    DO              shift and go to state 8
    (               shift and go to state 18
    NAME            shift and go to state 9

    stmt                           shift and go to state 4
    functioncall                   shift and go to state 14
    varlist                        shift and go to state 15
    prefixexp                      shift and go to state 16
    var                            shift and go to state 17

state 173

    (9) stmt -> FOR NAME = exp , exp , exp DO stmtlist END .
    ;               reduce using rule 9 (stmt -> FOR NAME = exp , exp , exp DO stmtlist END .)


Conflicts:

shift/reduce conflict for { in state 90 resolved as shift
shift/reduce conflict for ( in state 90 resolved as shift
shift/reduce conflict for { in state 127 resolved as shift
shift/reduce conflict for ( in state 127 resolved as shift
shift/reduce conflict for { in state 150 resolved as shift
shift/reduce conflict for ( in state 150 resolved as shift